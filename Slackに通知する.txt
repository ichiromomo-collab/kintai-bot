// Slackに通知する
function notifySlack(message) {

  // ★ 空メッセージは送らない
  if (!message || message.trim() === "") {
    Logger.log("notifySlack: empty message → 送信スキップ");
    return;
  }

  const token = "xoxb-9276453172948-10032330419026-h20lk5QAef94BQNiXltldRD8"; // ← Bot Tokenを貼り付け
  const channel = "C098HMJV3AB"; // 連絡チャンネルID
  const url = "https://slack.com/api/chat.postMessage";

  const payload = {
    channel: channel,
    text: message
  };

  const options = {
    method: "post",
    contentType: "application/json",
    headers: {
      Authorization: `Bearer ${token}`
    },
    payload: JSON.stringify(payload)
  };

  const response = UrlFetchApp.fetch(url, options);
  Logger.log(response.getContentText());
}

// Slackユーザー名を取得（display_name優先）
function getSlackUserName(userId) {
  const token = "xoxb-9276453172948-10032330419026-h20lk5QAef94BQNiXltldRD8";
  const url = "https://slack.com/api/users.info";

  const options = {
    method: "get",
    headers: {
      Authorization: "Bearer " + token
    },
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(`${url}?user=${userId}`, options);
  const text = response.getContentText();
  Logger.log("Slack raw response: " + text);
  const data = JSON.parse(text);

  if (data.ok) {
    return data.user.profile.display_name || data.user.real_name;
  } else {
    Logger.log("Slack API error: " + data.error);
    return userId;
  }
}


// ここから追加：Slackメッセージからプレーンテキストを取り出す
function extractPlainText(msg) {
  // 引数がないとき・変な値のときは空文字で返す
  if (!msg) return "";

  // 1) 普通の text があればそれを使う
  if (typeof msg.text === "string" && msg.text.trim() !== "") {
    return msg.text.trim();
  }

  // 2) Block Kit の中から text 情報を拾う
  if (msg.blocks && Array.isArray(msg.blocks)) {
    let text = "";

    msg.blocks.forEach(block => {
      if (block.type === "rich_text" && Array.isArray(block.elements)) {
        block.elements.forEach(el => {
          if (el.type === "rich_text_section" && Array.isArray(el.elements)) {
            el.elements.forEach(seg => {
              if (seg.type === "text" && typeof seg.text === "string") {
                text += seg.text;
              }
            });
          }
        });
      }
    });

    return text.trim();
  }

  // どれにも当てはまらないとき
  return "";
}

// Slackメッセージを取得して予定に変換
function fetchSlackMessages() {
  const token = "xoxb-9276453172948-10032330419026-h20lk5QAef94BQNiXltldRD8";
  const channel = "C098HMJV3AB";
  const url = "https://slack.com/api/conversations.history";

  const options = {
    method: "get",
    headers: { Authorization: "Bearer " + token },
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(`${url}?channel=${channel}&limit=20`, options);
  const data = JSON.parse(response.getContentText());
  Logger.log(JSON.stringify(data, null, 2));

  if (!data.ok) {
    Logger.log("Slack API error: " + data.error);
    return;
  }

  const messages = data.messages;
  const lastTs = PropertiesService.getScriptProperties().getProperty("lastProcessedTs");
  let newestTs = lastTs;

  // 新しいメッセージが下に来るよう逆順
  messages.reverse().forEach(msg => {
    const text = extractPlainText(msg);

    // 人の投稿 ＋ テキストあり ＋ まだ処理してない ts だけ
    if (
      text !== "" &&
      msg.user &&
      (!msg.subtype || msg.subtype === "thread_broadcast") &&
      (!lastTs || msg.ts > lastTs)
    ) {
      const userName = getSlackUserName(msg.user);
      const added = parseMessageAndAddEvent(text, userName);

      if (added) {
        notifySlack(`予定を追加しました：${text}`);
      }

      if (!newestTs || msg.ts > newestTs) {
        newestTs = msg.ts;
      }
    }
  });

  // ★ ここで “最後に処理した ts” を保存 → 次回はそこから先だけ読む
  if (newestTs && newestTs !== lastTs) {
    PropertiesService.getScriptProperties().setProperty("lastProcessedTs", newestTs);
    Logger.log("lastProcessedTs updated → " + newestTs);
  }
}

// Slackのメッセージ1件をカレンダー予定に変換
function parseMessageAndAddEvent(message, 担当者) {
  if (!message) {
    Logger.log("空のメッセージが渡されました");
    return false;
  }

  const calendar = CalendarApp.getCalendarById("houkan.omusubi1@gmail.com");

  let title = "予定";
  let startTime, endTime;

  // 「明日10時」
  const m1 = message.match(/明日.*?(\d{1,2})時/);
  if (m1) {
    const hour = parseInt(m1[1], 10);
    const next = new Date();
    next.setDate(next.getDate() + 1);
    startTime = new Date(next.getFullYear(), next.getMonth(), next.getDate(), hour, 0);
    endTime   = new Date(next.getFullYear(), next.getMonth(), next.getDate(), hour + 1, 0);
    title = "訪問予定";
  }

  // 「12/5 10:00」
  const m2 = message.match(/(\d{1,2})\/(\d{1,2}).*?(\d{1,2})[:：](\d{2})/);
  if (m2) {
    const year  = new Date().getFullYear();
    const month = parseInt(m2[1], 10) - 1;
    const day   = parseInt(m2[2], 10);
    const hour  = parseInt(m2[3], 10);
    const min   = parseInt(m2[4], 10);
    startTime = new Date(year, month, day, hour, min);
    endTime   = new Date(year, month, day, hour + 1, min);
  }

  // 「12/5」（時間なし）
  const m3 = message.match(/(\d{1,2})\/(\d{1,2})/);
  if (!startTime && m3) {
    const year  = new Date().getFullYear();
    const month = parseInt(m3[1], 10) - 1;
    const day   = parseInt(m3[2], 10);
    startTime = new Date(year, month, day, 10, 0);
    endTime   = new Date(year, month, day, 11, 0);
    title = "面談予定";
  }

  // タイトル補正
  if (message.includes("忘年会"))   title = "忘年会";
  if (message.includes("担当者会議")) title = "担当者会議";
  if (message.includes("歓迎会"))   title = "歓迎会";
  if (message.includes("求人"))     title = "求人対応";
  if (message.includes("見学"))     title = "見学対応";
  if (message.includes("面談"))     title = "面談予定";

  // 説明欄
  const description = `担当：${担当者}\n内容：${message}`;

  // 日付が決まらなければ終了
  if (!startTime || !endTime) {
    Logger.log("日付や時間が特定できませんでした: " + message);
    return false;
  }

  // 同一イベント確認（タイトル＋開始時刻で判定）
  const events = calendar.getEvents(startTime, endTime);
  const exists = events.some(e =>
    e.getTitle() === title &&
    e.getStartTime().getTime() === startTime.getTime()
  );

  if (exists) {
    Logger.log("既に同じ予定があります: " + title);
    return false;
  }

  // 作成
  const event = calendar.createEvent(title, startTime, endTime);
  event.setDescription(description);

  return true;
}

// おまけ：中括弧チェック（必要なら使う）
function checkBrackets() {
  const code = DriveApp.getFileById(ScriptApp.getScriptId())
                       .getBlob().getDataAsString();
  let stack = [];
  let line = 1;

  for (let i = 0; i < code.length; i++) {
    const c = code[i];
    if (c === "\n") line++;
    if (c === "{") stack.push(line);
    if (c === "}") {
      if (stack.length === 0) {
        Logger.log("❌ 余分な } を検出 → 行番号: " + line);
        return;
      }
      stack.pop();
    }
  }

  if (stack.length > 0) {
    Logger.log("❌ 閉じられていない { が存在 → 行番号: " +
               stack[stack.length - 1]);
  } else {
    Logger.log("⭕ 中括弧の整合性 OK");
  }
}
